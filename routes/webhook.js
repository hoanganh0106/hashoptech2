// Webhook Routes - MongoDB Version
const express = require('express');
const router = express.Router();
const config = require('../config');
const telegramService = require('../services/telegram');

// Import Models
const Order = require('../models/Order');
const Account = require('../models/Account');

/**
 * Handler function cho Sepay webhook
 */
async function handleSepayWebhook(req, res) {
  try {
    console.log('üì• Nh·∫≠n webhook t·ª´ Sepay:', req.body);

    const { transaction_id, amount, content, bank_code, status } = req.body;

    // TODO: L∆∞u payment log v√†o MongoDB n·∫øu c·∫ßn

    // Ch·ªâ x·ª≠ l√Ω giao d·ªãch th√†nh c√¥ng
    if (status !== 'success' && status !== 'completed') {
      console.log('‚ö†Ô∏è  Giao d·ªãch ch∆∞a ho√†n th√†nh:', status);
      return res.json({ success: true, message: 'ƒê√£ nh·∫≠n webhook' });
    }

    // T√¨m ƒë∆°n h√†ng kh·ªõp v·ªõi n·ªôi dung chuy·ªÉn kho·∫£n
    const orders = await Order.find({ paymentStatus: 'pending' });

    if (!orders || orders.length === 0) {
      console.log('‚ö†Ô∏è  Kh√¥ng c√≥ ƒë∆°n h√†ng pending');
      return res.json({ success: true, message: 'Kh√¥ng c√≥ ƒë∆°n h√†ng ph√π h·ª£p' });
    }

    // T√¨m ƒë∆°n h√†ng kh·ªõp v·ªõi n·ªôi dung CK
    let matchedOrder = null;
    const contentLower = content.toLowerCase().trim();

    for (const order of orders) {
      const orderCodeLower = order.orderCode.toLowerCase();
      
      // Ki·ªÉm tra kh·ªõp m√£ ƒë∆°n h√†ng v√† s·ªë ti·ªÅn
      if (contentLower.includes(orderCodeLower) && Math.abs(amount - order.totalAmount) < 1000) {
        matchedOrder = order;
        break;
      }
    }

    if (!matchedOrder) {
      console.log('‚ö†Ô∏è  Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng kh·ªõp');
      
      // G·ª≠i th√¥ng b√°o Telegram v·ªÅ giao d·ªãch kh√¥ng x√°c ƒë·ªãnh
      await telegramService.sendMessage(
        `‚ö†Ô∏è GIAO D·ªäCH KH√îNG X√ÅC ƒê·ªäNH\n\n` +
        `üí∞ S·ªë ti·ªÅn: ${amount.toLocaleString()}ƒë\n` +
        `üìù N·ªôi dung: ${content}\n` +
        `üè¶ Ng√¢n h√†ng: ${bank_code}\n` +
        `üÜî M√£ GD: ${transaction_id}\n\n` +
        `Vui l√≤ng ki·ªÉm tra th·ªß c√¥ng!`
      );
      
      return res.json({ success: true, message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng kh·ªõp' });
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
    matchedOrder.paymentStatus = 'paid';
    matchedOrder.paidAt = new Date();
    matchedOrder.bankTransactionId = transaction_id;
    await matchedOrder.save();

    console.log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t ƒë∆°n h√†ng:', matchedOrder.orderCode);

    // T·ª± ƒë·ªông giao h√†ng n·∫øu c√≥ t√†i kho·∫£n trong kho
    const deliveredAccounts = [];

    for (const item of matchedOrder.items) {
      for (let i = 0; i < item.quantity; i++) {
        const account = await Account.findOne({
          productId: item.productId,
          status: 'available',
          variantName: item.variantName
        });

        if (account) {
          deliveredAccounts.push({
            productId: item.productId,
            variantName: item.variantName,
            username: account.username,
            password: account.password,
            deliveredAt: new Date()
          });

          // ƒê√°nh d·∫•u account ƒë√£ b√°n
          account.status = 'sold';
          account.soldToOrderId = matchedOrder._id;
          account.soldAt = new Date();
          await account.save();
        }
      }
    }

    // C·∫≠p nh·∫≠t delivery status
    if (deliveredAccounts.length > 0) {
      matchedOrder.deliveredAccounts = deliveredAccounts;
      matchedOrder.deliveryStatus = 'completed';
      matchedOrder.deliveredAt = new Date();
      await matchedOrder.save();
    }

    // G·ª≠i th√¥ng b√°o Telegram
    let message = `üéâ ƒê∆†N H√ÄNG THANH TO√ÅN TH√ÄNH C√îNG\n\n` +
      `üì¶ M√£ ƒë∆°n: ${matchedOrder.orderCode}\n` +
      `üë§ Kh√°ch h√†ng: ${matchedOrder.customerName}\n` +
      `üìß Email: ${matchedOrder.customerEmail}\n` +
      `üí∞ S·ªë ti·ªÅn: ${matchedOrder.totalAmount.toLocaleString()}ƒë\n` +
      `üè¶ M√£ GD: ${transaction_id}\n\n`;

    if (deliveredAccounts.length > 0) {
      message += `‚úÖ ƒê√£ giao ${deliveredAccounts.length} t√†i kho·∫£n\n\n`;
      message += `üìã Danh s√°ch t√†i kho·∫£n:\n`;
      deliveredAccounts.forEach((acc, index) => {
        message += `${index + 1}. ${acc.variantName || 'N/A'}\n`;
        message += `   ‚Ä¢ User: ${acc.username}\n`;
        message += `   ‚Ä¢ Pass: ${acc.password}\n`;
      });
    } else {
      message += `‚ö†Ô∏è Ch∆∞a giao h√†ng (kh√¥ng ƒë·ªß t√†i kho·∫£n trong kho)`;
    }

    await telegramService.sendMessage(message);

    // TODO: G·ª≠i email cho kh√°ch h√†ng v·ªõi th√¥ng tin t√†i kho·∫£n

    res.json({ 
      success: true, 
      message: 'ƒê√£ x·ª≠ l√Ω thanh to√°n',
      orderCode: matchedOrder.orderCode,
      delivered: deliveredAccounts.length > 0
    });

  } catch (error) {
    console.error('‚ùå L·ªói x·ª≠ l√Ω webhook:', error);
    res.status(500).json({ error: 'L·ªói x·ª≠ l√Ω webhook' });
  }
}

/**
 * POST /api/webhook/sepay - Endpoint webhook ch√≠nh
 */
router.post('/sepay', handleSepayWebhook);

/**
 * POST /hooks/sepay-payment/ - Endpoint t∆∞∆°ng th√≠ch v·ªõi c·∫•u h√¨nh Sepay c·ªßa user
 */
router.post('/sepay-payment/', handleSepayWebhook);

module.exports = router;
